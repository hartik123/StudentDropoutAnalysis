"use strict";

// src/ECharts.tsx
import React4, { useCallback, useContext, useImperativeHandle, useMemo, useRef } from "react";
import _merge2 from "lodash.merge";
import ReactEchartsCore from "echarts-for-react/lib/core";
import * as echarts2 from "echarts/core";
import { CanvasRenderer } from "echarts/renderers";

// src/utils.ts
import React2 from "react";
import _merge from "lodash.merge";
import _omit from "lodash.omit";
import flattenChildren from "react-keyed-flatten-children";
import * as echarts from "echarts/core";
import { TitleComponent } from "echarts/components";

// src/constants.ts
import React from "react";
var EChartsContext = React.createContext({});
var symbols = {
  typeKey: Symbol.for("$$typeKey"),
  dataset: Symbol.for("$$dataset"),
  dataZoom: Symbol.for("$$dataZoom"),
  legend: Symbol.for("$$legend"),
  radar: Symbol.for("$$radar"),
  tooltip: Symbol.for("$$tooltip"),
  visualMap: Symbol.for("$$visualMap"),
  xAxis: Symbol.for("$$xAxis"),
  yAxis: Symbol.for("$$yAxis"),
  bars: Symbol.for("$$bars"),
  funnel: Symbol.for("$$funnel"),
  line: Symbol.for("$$line"),
  map: Symbol.for("$$map"),
  pie: Symbol.for("$$pie"),
  radarLine: Symbol.for("$$radarLine"),
  sankey: Symbol.for("$$sankey"),
  scatter: Symbol.for("$$scatter"),
  tree: Symbol.for("$$tree"),
  treemap: Symbol.for("$$treemap")
};
symbols.components = [
  symbols.dataZoom,
  symbols.legend,
  symbols.radar,
  symbols.tooltip,
  symbols.visualMap,
  symbols.xAxis,
  symbols.yAxis
];
symbols.series = [
  symbols.bars,
  symbols.funnel,
  symbols.line,
  symbols.map,
  symbols.pie,
  symbols.radarLine,
  symbols.sankey,
  symbols.scatter,
  symbols.tree,
  symbols.treemap
];

// src/utils.ts
echarts.use([TitleComponent]);
function is(element, name2) {
  return element.type[symbols.typeKey] === Symbol.for(`$$${name2}`);
}
function isSeries(element) {
  return symbols.series.includes(element.type[symbols.typeKey]);
}
function transformTextOption(option, defaultOption2) {
  if (option === void 0 || option === true) {
    return defaultOption2;
  }
  if (option === false) {
    return { show: false };
  }
  if (typeof option === "function") {
    return {
      ...defaultOption2,
      show: true,
      formatter: option
    };
  }
  if (typeof option === "object") {
    return _merge({
      ...defaultOption2,
      show: true
    }, option);
  }
  return {
    ...defaultOption2,
    show: true,
    formatter() {
      return option;
    }
  };
}
function randstr(length = 16) {
  let text = "";
  const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  for (let i = 0; i < length; i += 1) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }
  return text;
}
function excludeEchartsProps(props) {
  return _omit(props, ["option", "locale", "height", "loading"]);
}
function createEChartsOptionFromChildren(children, _) {
  const option = {};
  const validChildren = flattenChildren(children).filter((child) => React2.isValidElement(child));
  const series = validChildren.filter((child) => {
    return symbols.series.includes(child.type[symbols.typeKey]);
  });
  const context = {
    ..._,
    series
  };
  validChildren.forEach((child) => {
    var _a, _b;
    (_b = (_a = child.type).tapEChartsOption) == null ? void 0 : _b.call(_a, option, excludeEchartsProps(child.props), context);
  });
  return option;
}
function isDataEmpty(option) {
  if (option.dataset) {
    return isDatasetEmpty(option.dataset);
  }
  return isSeriesEmpty(option.series);
}
function isDatasetEmpty(dataset) {
  if (!dataset.source) {
    return true;
  }
  if (Array.isArray(dataset.source)) {
    return dataset.source.length < 1;
  }
  return Object.getOwnPropertyNames(dataset.source).length < 1;
}
function isSeriesEmpty(series) {
  return !series || series.every((serie) => {
    if (serie.type === "sankey") {
      return (!serie.nodes || serie.nodes.length < 1) && (!serie.data || serie.data.length < 1);
    }
    return !serie.data || serie.data.length < 1;
  });
}

// src/ECharts.tsx
import * as themes from "echarts-theme-rsuite";

// src/assets/chart-nodata.svg
import * as React3 from "react";
var SvgChartNodata = (props) => /* @__PURE__ */ React3.createElement("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  width: 104,
  height: 46,
  viewBox: "0 0 104 46",
  ...props
}, /* @__PURE__ */ React3.createElement("g", {
  fill: "none",
  fillRule: "evenodd",
  opacity: 0.46
}, /* @__PURE__ */ React3.createElement("g", {
  fillRule: "nonzero",
  transform: "translate(60 10)"
}, /* @__PURE__ */ React3.createElement("path", {
  fill: "#E5E5EA",
  d: "M17,0 L40,0 C42.209139,0 44,1.790861 44,4 L44,32 C44,34.209139 42.209139,36 40,36 L4,36 C1.790861,36 0,34.209139 0,32 L0,30 L1,30 L1,32 C1,33.5976809 2.24891996,34.9036609 3.82372721,34.9949073 L4,35 L40,35 C41.5976809,35 42.9036609,33.75108 42.9949073,32.1762728 L43,32 L43,4 C43,2.40231912 41.75108,1.09633912 40.1762728,1.00509269 L40,1 L17,1 L17,0 Z"
}), /* @__PURE__ */ React3.createElement("path", {
  fill: "#C5C6C7",
  d: "M21,9 L21,27 L16.8737865,27.0007613 C16.9355797,26.7608745 16.9756782,26.5122749 16.9918654,26.2571791 L17,26 L16.9997865,9 L21,9 Z"
}), /* @__PURE__ */ React3.createElement("polygon", {
  fill: "#D9D9D9",
  points: "26 18 22 18 22 27 26 27"
}), /* @__PURE__ */ React3.createElement("polygon", {
  fill: "#E5E5EA",
  points: "32 23 27 23 27 27 32 27"
}), /* @__PURE__ */ React3.createElement("polygon", {
  fill: "#E5E5EA",
  points: "32 18 27 18 27 22 32 22"
}), /* @__PURE__ */ React3.createElement("polygon", {
  fill: "#D9D9D9",
  points: "32 9 22 9 22 17 32 17"
})), /* @__PURE__ */ React3.createElement("g", {
  fillRule: "nonzero",
  transform: "translate(0 10)"
}, /* @__PURE__ */ React3.createElement("path", {
  fill: "#E5E5EA",
  d: "M44,30 L44,32 C44,34.209139 42.209139,36 40,36 L4,36 C1.790861,36 0,34.209139 0,32 L0,4 C0,1.790861 1.790861,0 4,0 L27,0 L27,1 L4,1 C2.40231912,1 1.09633912,2.24891996 1.00509269,3.82372721 L1,4 L1,32 C1,33.5976809 2.24891996,34.9036609 3.82372721,34.9949073 L4,35 L40,35 C41.5976809,35 42.9036609,33.75108 42.9949073,32.1762728 L43,32 L43,30 L44,30 Z"
}), /* @__PURE__ */ React3.createElement("g", {
  transform: "matrix(-1 0 0 1 32 8)"
}, /* @__PURE__ */ React3.createElement("path", {
  fill: "#E5E5EA",
  d: "M7.49088855,0.317393442 L8.76101043,6.45950992 C7.29877139,6.97118377 6.25,8.36311505 6.25,10 C6.25,12.0710678 7.92893219,13.75 10,13.75 C11.5445601,13.75 12.8710193,12.8161995 13.4456235,11.4823526 L13.5300246,11.2684986 L19.6839139,12.5040464 C18.5724003,16.8150611 14.6581413,20 10,20 C8.15753882,20 6.4314569,19.5017211 4.94915868,18.6325678 C4.97172334,18.4951443 4.98679793,18.3554558 4.99434047,18.2138361 L5,18 L4.99993491,1.33785961 C5.68154258,0.943564009 6.41400922,0.62740983 7.18508527,0.401646632 L7.49088855,0.317393442 Z"
}), /* @__PURE__ */ React3.createElement("path", {
  fill: "#C5C6C7",
  d: "M10,0 C15.4186428,0 19.8306786,4.30979721 19.9952415,9.68852584 L20,10 L13.75,10 C13.75,8.0028989 12.18885,6.3704239 10.220341,6.25636587 L10,6.25 L10,0 Z"
}))), /* @__PURE__ */ React3.createElement("g", {
  transform: "translate(27)"
}, /* @__PURE__ */ React3.createElement("path", {
  fill: "#C5C6C7",
  fillRule: "nonzero",
  d: "M46,0 C48.209139,0 50,1.790861 50,4 L50,36 C50,38.209139 48.209139,40 46,40 L4,40 C1.790861,40 0,38.209139 0,36 L0,4 C0,1.790861 1.790861,0 4,0 L46,0 Z M46,1 L4,1 C2.40231912,1 1.09633912,2.24891996 1.00509269,3.82372721 L1,4 L1,36 C1,37.5976809 2.24891996,38.9036609 3.82372721,38.9949073 L4,39 L46,39 C47.5976809,39 48.9036609,37.75108 48.9949073,36.1762728 L49,36 L49,4 C49,2.40231912 47.75108,1.09633912 46.1762728,1.00509269 L46,1 Z"
}), /* @__PURE__ */ React3.createElement("g", {
  transform: "translate(13 8)"
}, /* @__PURE__ */ React3.createElement("rect", {
  width: 3,
  height: 9,
  x: 1,
  y: 15,
  fill: "#C5C6C7",
  rx: 0.752
}), /* @__PURE__ */ React3.createElement("rect", {
  width: 3,
  height: 8,
  x: 7,
  y: 16,
  fill: "#C5C6C7",
  rx: 0.752
}), /* @__PURE__ */ React3.createElement("rect", {
  width: 3,
  height: 12,
  x: 13,
  y: 12,
  fill: "#C5C6C7",
  rx: 0.752
}), /* @__PURE__ */ React3.createElement("rect", {
  width: 3,
  height: 15,
  x: 19,
  y: 9,
  fill: "#C5C6C7",
  rx: 0.752
}), /* @__PURE__ */ React3.createElement("path", {
  fill: "#A6A6A6",
  fillRule: "nonzero",
  d: "M15.1740335,0.269902413 C15.3523155,0.055964011 15.6312917,-0.0387293895 15.8973285,0.0145685364 L16.0287425,0.0536831948 L23.5287425,3.05368319 C23.9133301,3.20751825 24.1003921,3.64399608 23.946557,4.02858372 C23.8098148,4.3704394 23.4497498,4.55622538 23.1013153,4.48524744 L22.9716565,4.44639823 L15.9781995,1.64854071 L8.82636546,10.230179 C8.64808346,10.4441174 8.36910733,10.5388108 8.10307053,10.4855129 L7.9716565,10.4463982 L0.471656497,7.44639823 C0.0870688596,7.29256318 -0.0999930687,6.85608534 0.0538419864,6.47149771 C0.190584258,6.12964203 0.550649217,5.94385605 0.899083667,6.01483399 L1.02874251,6.05368319 L8.0221995,8.85004071 L15.1740335,0.269902413 Z"
})))));

// src/ECharts.tsx
echarts2.use([CanvasRenderer]);
echarts2.registerTheme("rsuite_light", themes.light);
echarts2.registerTheme("rsuite_dark", themes.dark);
var styles = {
  blockCenter: {
    width: "100%",
    height: "100%",
    display: "flex",
    flexDirection: "column",
    alignItems: "center",
    justifyContent: "center",
    color: "#8e8e93",
    fontSize: 14,
    fontWeight: "normal",
    lineHeight: "20px"
  },
  loaderWrap: {
    position: "absolute",
    top: 0,
    left: 0,
    backgroundColor: "rgba(255, 255, 255, 0.9)"
  }
};
var defaultOption = {
  grid: {
    containLabel: true
  }
};
function ECharts({
  height = 300,
  locale = {
    emptyMessage: "No data found",
    loading: "Loading..."
  },
  option = {},
  children,
  renderEmptyPlaceholder,
  ...props
}, ref) {
  const echartsRef = useRef();
  useImperativeHandle(ref, () => echartsRef.current);
  const context = useContext(EChartsContext);
  const renderEmptyMessage = useCallback(() => {
    if (typeof renderEmptyPlaceholder !== "undefined") {
      return renderEmptyPlaceholder();
    }
    return /* @__PURE__ */ React4.createElement("div", {
      className: "rs-echarts-body-info",
      style: styles.blockCenter
    }, /* @__PURE__ */ React4.createElement(SvgChartNodata, {
      style: { marginBottom: 10 }
    }), locale.emptyMessage);
  }, [renderEmptyPlaceholder, locale]);
  const renderLoader = useCallback(() => {
    return /* @__PURE__ */ React4.createElement("div", {
      className: "rs-echarts-loader-wrap",
      style: { ...styles.blockCenter, ...styles.loaderWrap }
    }, locale.loading);
  }, [locale]);
  const onChartReady = useCallback((echarts19) => {
    echartsRef.current = echarts19;
  }, []);
  const { className, style, loading, ...echartsForReactProps } = props;
  const echartsOption = useMemo(() => {
    return children ? _merge2({}, defaultOption, option, createEChartsOptionFromChildren(children, context)) : option;
  }, [children, context, option]);
  const dataEmpty = isDataEmpty(echartsOption);
  return /* @__PURE__ */ React4.createElement("div", {
    className: `rs-echarts ${className || ""}`,
    style: { position: "relative", height, ...style }
  }, !loading && dataEmpty && renderEmptyMessage(), /* @__PURE__ */ React4.createElement(ReactEchartsCore, {
    echarts: echarts2,
    option: echartsOption,
    style: { height: "100%", visibility: dataEmpty ? "hidden" : "visible" },
    onChartReady,
    notMerge: true,
    theme: "rsuite_light",
    ...echartsForReactProps
  }), children, loading && renderLoader());
}
if (process.env.NODE_ENV !== "production") {
  ECharts.displayName = "ECharts";
}
var ECharts_default = React4.forwardRef(ECharts);

// src/components/Dataset.ts
import * as echarts3 from "echarts/core";
import { DatasetComponent } from "echarts/components";
import _merge3 from "lodash.merge";
echarts3.use([DatasetComponent]);
var Dataset = (_) => null;
Dataset[symbols.typeKey] = symbols.dataset;
Dataset.tapEChartsOption = (option, props) => {
  option.dataset = _merge3({}, props);
};
if (process.env.NODE_ENV !== "production") {
  Dataset.displayName = "Dataset";
}
var Dataset_default = Dataset;

// src/components/DataZoom.ts
import * as echarts4 from "echarts/core";
import { DataZoomComponent } from "echarts/components";
import _merge4 from "lodash.merge";
echarts4.use([DataZoomComponent]);
var DataZoom = (_) => null;
DataZoom[symbols.typeKey] = symbols.dataZoom;
DataZoom.tapEChartsOption = (option, props) => {
  function getOption() {
    return _merge4({
      type: "slider"
    }, props);
  }
  const dataZoomOption = getOption();
  if (!option.dataZoom) {
    option.dataZoom = dataZoomOption;
  } else if (!Array.isArray(option.dataZoom)) {
    option.dataZoom = [option.dataZoom, dataZoomOption];
  } else {
    option.dataZoom.push(dataZoomOption);
  }
};
if (process.env.NODE_ENV !== "production") {
  DataZoom.displayName = "DataZoom";
}
var DataZoom_default = DataZoom;

// src/components/Legend.ts
import * as echarts5 from "echarts/core";
import { LegendComponent } from "echarts/components";
import _merge5 from "lodash.merge";
echarts5.use([LegendComponent]);
var Legend = (_) => null;
Legend[symbols.typeKey] = symbols.legend;
Legend.tapEChartsOption = (option, props, context) => {
  function getOption() {
    const { chartType } = context;
    const legendOption2 = {
      show: true,
      bottom: 10
    };
    if (chartType === "pie") {
      legendOption2.icon = "circle";
    }
    return _merge5(legendOption2, props);
  }
  const legendOption = getOption();
  if (!option.legend) {
    option.legend = legendOption;
  } else if (!Array.isArray(option.legend)) {
    option.legend = [option.legend, legendOption];
  } else {
    option.legend.push(legendOption);
  }
};
if (process.env.NODE_ENV !== "production") {
  Legend.displayName = "Legend";
}
var Legend_default = Legend;

// src/components/Radar.ts
import * as echarts6 from "echarts/core";
import { RadarComponent } from "echarts/components";
import _merge6 from "lodash.merge";
echarts6.use([RadarComponent]);
var Radar = () => null;
Radar[symbols.typeKey] = symbols.radar;
Radar.tapEChartsOption = (option, props) => {
  function getOption() {
    const { circle = false, ...rest } = props;
    return _merge6({
      axisName: {
        color: "#575757"
      },
      axisNameGap: 10,
      shape: circle ? "circle" : "polygon",
      splitArea: {
        areaStyle: {
          color: ["#FFFFFF", "#F7F7FA"]
        }
      }
    }, rest);
  }
  const radarOption = getOption();
  if (!option.radar) {
    option.radar = radarOption;
  } else if (!Array.isArray(option.radar)) {
    option.radar = [option.radar, radarOption];
  } else {
    option.radar.push(radarOption);
  }
};
if (process.env.NODE_ENV !== "production") {
  Radar.displayName = "Radar";
}
var Radar_default = Radar;

// src/components/Tooltip.ts
import * as echarts7 from "echarts/core";
import { TooltipComponent } from "echarts/components";
import _merge7 from "lodash.merge";
echarts7.use([TooltipComponent]);
var Tooltip = (_) => null;
Tooltip[symbols.typeKey] = symbols.tooltip;
Tooltip.tapEChartsOption = (option, props, context) => {
  function getOption() {
    const { chartType, series } = context;
    const hasAxis = chartType === "bar" || chartType === "line" || !!series.find((comp) => comp.type[symbols.typeKey] === symbols.xAxis || comp.type[symbols.typeKey] === symbols.yAxis);
    return _merge7({
      show: true,
      trigger: hasAxis ? "axis" : "item",
      axisPointer: {
        type: "none"
      }
    }, props);
  }
  option.tooltip = getOption();
};
if (process.env.NODE_ENV !== "production") {
  Tooltip.displayName = "Tooltip";
}
var Tooltip_default = Tooltip;

// src/components/VisualMap.ts
import * as echarts8 from "echarts/core";
import { VisualMapComponent } from "echarts/components";
import _merge8 from "lodash.merge";
echarts8.use([VisualMapComponent]);
var VisualMap = (_) => null;
VisualMap[symbols.typeKey] = symbols.visualMap;
VisualMap.tapEChartsOption = (option, props, context) => {
  function getComponentOption() {
    const { type = "continuous", ...rest } = props;
    const { chartData } = context;
    let inRange = {
      colorHue: [198, 199],
      colorSaturation: [1, 1],
      colorLightness: [0.88, 0.451]
    };
    if (type === "piecewise") {
      inRange = {
        symbol: "rect"
      };
    }
    const visualMapOption = _merge8({
      type,
      left: 0,
      bottom: 0,
      text: ["\u6700\u5927\u503C", "\u6700\u5C0F\u503C"],
      textGap: 5,
      orient: "horizontal",
      inverse: true,
      min: 0,
      itemGap: 1,
      symbolSize: [18, 14],
      textStyle: {
        color: "#8e8e93"
      },
      inRange
    }, rest);
    if (chartData && chartData.length > 0 && !visualMapOption.max) {
      visualMapOption.max = chartData.reduce((max, d) => Math.max(max, d[1]), -Infinity);
    }
    return visualMapOption;
  }
  option.visualMap = getComponentOption();
};
if (process.env.NODE_ENV !== "production") {
  VisualMap.displayName = "VisualMap";
}
var VisualMap_default = VisualMap;

// src/components/XAxis.ts
import _merge9 from "lodash.merge";
var XAxis = () => null;
XAxis[symbols.typeKey] = symbols.xAxis;
XAxis.tapEChartsOption = (option, props, context) => {
  function getOption() {
    const { axisLabel, axisLine, splitLine, ...rest } = props;
    const { series } = context;
    return _merge9(rest.type === "category" ? {
      boundaryGap: !!series.find((comp) => comp.type[symbols.typeKey] === symbols.bars)
    } : {}, {
      nameTextStyle: {
        fontSize: 12,
        color: "#575757"
      }
    }, axisLabel ? {
      axisLabel: transformTextOption(axisLabel)
    } : {}, typeof axisLine === "boolean" ? {
      axisLine: {
        show: axisLine
      }
    } : axisLine, typeof splitLine === "boolean" ? {
      splitLine: {
        show: splitLine
      }
    } : splitLine, rest);
  }
  const xAxisOption = getOption();
  if (!option.xAxis) {
    option.xAxis = xAxisOption;
  } else if (!Array.isArray(option.xAxis)) {
    option.xAxis = [option.xAxis, xAxisOption];
  } else {
    option.xAxis.push(xAxisOption);
  }
};
if (process.env.NODE_ENV !== "production") {
  XAxis.displayName = "XAxis";
}
var XAxis_default = XAxis;

// src/components/YAxis.ts
import _merge10 from "lodash.merge";
var YAxis = (_) => null;
YAxis.defaultProps = {
  show: true,
  type: "value"
};
YAxis[symbols.typeKey] = symbols.yAxis;
YAxis.tapEChartsOption = (option, props) => {
  function getOption() {
    const { name: name2, axisLabel, axisLine, splitLine, transposeNameText = false, ...rest } = props;
    return _merge10({
      name: name2,
      nameTextStyle: {
        fontSize: 12,
        color: "#575757"
      }
    }, name2 && rest.nameLocation === "middle" && transposeNameText ? {
      nameRotate: 0,
      name: name2.split("").join("\n")
    } : {}, typeof axisLine === "boolean" ? {
      axisLine: {
        show: axisLine
      }
    } : axisLine, typeof splitLine !== "undefined" ? {
      splitLine: _merge10({
        show: !!splitLine
      }, typeof splitLine !== "boolean" && splitLine)
    } : {}, axisLabel ? {
      axisLabel: transformTextOption(axisLabel)
    } : {}, rest);
  }
  const yAxisOption = getOption();
  if (!option.yAxis) {
    option.yAxis = yAxisOption;
  } else if (!Array.isArray(option.yAxis)) {
    option.yAxis = [option.yAxis, yAxisOption];
  } else {
    option.yAxis.push(yAxisOption);
  }
};
if (process.env.NODE_ENV !== "production") {
  YAxis.displayName = "YAxis";
}
var YAxis_default = YAxis;

// src/series/Bars.ts
import * as echarts9 from "echarts/core";
import { BarChart } from "echarts/charts";
import _merge11 from "lodash.merge";
echarts9.use([BarChart]);
var Bars = () => null;
var defaultBarsStackKey = randstr();
Bars[symbols.typeKey] = symbols.bars;
Bars.tapEChartsOption = (option, props, context) => {
  function getSeriesOption() {
    const { stack, color, label, ...rest } = props;
    const { chartType, horizontal, series } = context;
    const barsSeriesCount = series.filter((comp) => comp.type[symbols.typeKey] === symbols.bars).length;
    const stackedBars = stack ? series.filter((comp) => comp.type[symbols.typeKey] === symbols.bars && comp.props.stack === stack) : [];
    const stacked = stackedBars.length > 1;
    const stackTop = stackedBars.findIndex((comp) => comp.type[symbols.typeKey] === symbols.bars && comp.props.name === rest.name) === stackedBars.length - 1;
    let borderRadius;
    if (stacked && !stackTop) {
      borderRadius = 0;
    } else {
      borderRadius = chartType === "bar" && horizontal ? [0, 5, 5, 0] : [5, 5, 0, 0];
    }
    return _merge11({
      type: "bar",
      barWidth: (!stack && barsSeriesCount) > 1 ? 6 : 20,
      stack: typeof stack === "boolean" ? defaultBarsStackKey : stack,
      itemStyle: {
        color: Array.isArray(color) ? ({ dataIndex }) => color[dataIndex] : color,
        borderRadius
      },
      label: transformTextOption(label, {
        position: horizontal ? "right" : "top"
      })
    }, rest);
  }
  if (!option.series) {
    option.series = [];
  }
  option.series.push(getSeriesOption());
};
if (process.env.NODE_ENV !== "production") {
  Bars.displayName = "Bars";
}
var Bars_default = Bars;

// src/series/Funnel.ts
import * as echarts10 from "echarts/core";
import { FunnelChart } from "echarts/charts";
import _merge12 from "lodash.merge";
echarts10.use([FunnelChart]);
var Funnel = (_) => null;
Funnel.defaultProps = {
  asc: false
};
Funnel[symbols.typeKey] = symbols.funnel;
Funnel.tapEChartsOption = (option, props) => {
  function getSeriesOption() {
    const { data, asc, sort = asc ? "ascending" : "descending", label, ...rest } = props;
    return _merge12({
      type: "funnel",
      data: data == null ? void 0 : data.map(([name2, value]) => ({
        name: name2,
        value
      })).sort((d1, d2) => d2.value - d1.value),
      sort,
      label: transformTextOption(label, {
        show: true,
        position: "inside",
        formatter: ({ value }) => value,
        fontSize: 14
      })
    }, rest);
  }
  if (!option.series) {
    option.series = [];
  }
  option.series.push(getSeriesOption());
};
if (process.env.NODE_ENV !== "production") {
  Funnel.displayName = "Funnel";
}
var Funnel_default = Funnel;

// src/series/Line.ts
import * as echarts11 from "echarts/core";
import { LineChart } from "echarts/charts";
import _merge13 from "lodash.merge";
echarts11.use([LineChart]);
var Line = (_) => null;
Line[symbols.typeKey] = symbols.line;
var defaultLineStackKey = randstr();
Line.tapEChartsOption = (option, props) => {
  function getSeriesOption() {
    const { stack, area, ...rest } = props;
    return _merge13({
      type: "line",
      symbol: "none",
      stack: typeof stack === "boolean" ? defaultLineStackKey : stack,
      areaStyle: area && { opacity: stack ? 0.6 : 0.2 }
    }, rest);
  }
  if (!option.series) {
    option.series = [];
  }
  option.series.push(getSeriesOption());
};
if (process.env.NODE_ENV !== "production") {
  Line.displayName = "Line";
}
var Line_default = Line;

// src/series/Map.ts
import * as echarts12 from "echarts/core";
import { MapChart } from "echarts/charts";
import _merge14 from "lodash.merge";
echarts12.use([MapChart]);
var Map = (_) => null;
Map[symbols.typeKey] = symbols.map;
Map.tapEChartsOption = (option, props) => {
  function getSeriesOption() {
    const { map, name: name2, data, nameMap, ...rest } = props;
    return _merge14({
      type: "map",
      map,
      name: name2,
      data: data == null ? void 0 : data.map(([name3, value]) => ({
        name: nameMap && nameMap[name3] || name3,
        value
      })),
      itemStyle: {
        areaColor: "#E5E5EA",
        borderColor: "#ffffff",
        borderWidth: 1
      },
      label: {
        fontSize: 10
      },
      emphasis: {
        label: {
          color: "rgb(131, 56, 236)"
        },
        itemStyle: {
          areaColor: "rgba(131, 56, 236, .3)",
          borderColor: "rgb(131, 56, 236)"
        }
      },
      nameMap
    }, rest);
  }
  if (!option.series) {
    option.series = [];
  }
  option.series.push(getSeriesOption());
};
if (process.env.NODE_ENV !== "production") {
  Map.displayName = "Map";
}
var Map_default = Map;

// src/series/Pie.ts
import * as echarts13 from "echarts/core";
import { PieChart } from "echarts/charts";
import _merge15 from "lodash.merge";
echarts13.use([PieChart]);
var Pie = (_) => null;
Pie.defaultProps = {
  data: [],
  donut: false
};
Pie[symbols.typeKey] = symbols.pie;
Pie.tapEChartsOption = (option, props) => {
  function getSeriesOption() {
    const { radius, donut, label, ...rest } = props;
    const pieOption = _merge15({
      type: "pie",
      radius: composeRadiusOption(radius, donut),
      center: ["50%", "50%"]
    }, rest);
    if (label !== void 0) {
      pieOption.label = transformTextOption(label);
    }
    return pieOption;
  }
  if (!option.series) {
    option.series = [];
  }
  option.series.push(getSeriesOption());
};
if (process.env.NODE_ENV !== "production") {
  Pie.displayName = "Pie";
}
var Pie_default = Pie;
function composeRadiusOption(radiusProp, donutProp) {
  if (Array.isArray(radiusProp))
    return radiusProp;
  let outerRadius = 80;
  if (typeof radiusProp === "string") {
    outerRadius = parseFloat(radiusProp) || 80;
  } else if (typeof radiusProp === "number") {
    outerRadius = radiusProp;
  }
  const innerRadius = outerRadius - 15;
  return donutProp ? [`${innerRadius}%`, `${outerRadius}%`] : `${outerRadius}%`;
}

// src/series/RadarLine.ts
import * as echarts14 from "echarts/core";
import { RadarChart } from "echarts/charts";
echarts14.use([RadarChart]);
var RadarLine = (_) => null;
RadarLine[symbols.typeKey] = symbols.radarLine;
RadarLine.tapEChartsOption = (option, props) => {
  var _a;
  const { name: name2, data } = props;
  if (!option.series) {
    option.series = [];
  }
  let radarSerieOption = (_a = option.series) == null ? void 0 : _a.find((series) => series.type === "radar");
  if (!radarSerieOption) {
    radarSerieOption = {
      type: "radar",
      symbol: "none",
      lineStyle: {
        width: 2
      },
      emphasis: {
        lineStyle: {
          width: 3
        },
        areaStyle: {
          opacity: 0.2
        }
      },
      data: []
    };
    option.series.push(radarSerieOption);
  }
  if (!radarSerieOption.data) {
    radarSerieOption.data = [];
  }
  radarSerieOption.data.push({
    name: name2,
    value: data
  });
};
if (process.env.NODE_ENV !== "production") {
  RadarLine.displayName = "RadarLine";
}
var RadarLine_default = RadarLine;

// src/series/Sankey.ts
import * as echarts15 from "echarts/core";
import { SankeyChart } from "echarts/charts";
import _merge16 from "lodash.merge";
echarts15.use([SankeyChart]);
var Sankey = (_) => null;
Sankey[symbols.typeKey] = symbols.sankey;
Sankey.tapEChartsOption = (option, props) => {
  function getSeriesOption() {
    return _merge16({
      type: "sankey",
      nodeWidth: 30,
      nodeGap: 20,
      itemStyle: {
        borderWidth: 0
      },
      lineStyle: {
        color: "#cfcfcf",
        curveness: 0.5
      }
    }, props);
  }
  if (!option.series) {
    option.series = [];
  }
  option.series.push(getSeriesOption());
};
if (process.env.NODE_ENV !== "production") {
  Sankey.displayName = "Sankey";
}
var Sankey_default = Sankey;

// src/series/Scatter.ts
import * as echarts16 from "echarts/core";
import { ScatterChart } from "echarts/charts";
import _merge17 from "lodash.merge";
echarts16.use([ScatterChart]);
var Scatter = (_) => null;
Scatter[symbols.typeKey] = symbols.scatter;
Scatter.tapEChartsOption = (option, props, context) => {
  function getSeriesOption() {
    const { ...rest } = props;
    const { chartType } = context;
    return _merge17({
      type: "scatter",
      symbol: chartType === "bar" ? "emptyCircle" : "circle",
      symbolSize: 9,
      itemStyle: {
        opacity: chartType === "bar" ? 1 : 0.7
      },
      emphasis: {
        itemStyle: {
          opacity: 1
        }
      }
    }, rest);
  }
  if (!option.series) {
    option.series = [];
  }
  option.series.push(getSeriesOption());
};
if (process.env.NODE_ENV !== "production") {
  Scatter.displayName = "Scatter";
}
var Scatter_default = Scatter;

// src/series/Tree.ts
import * as echarts17 from "echarts/core";
import { TreeChart } from "echarts/charts";
import _merge18 from "lodash.merge";
echarts17.use([TreeChart]);
var Tree = (_) => null;
Tree.defaultProps = {
  data: []
};
Tree[symbols.typeKey] = symbols.tree;
Tree.tapEChartsOption = (option, props) => {
  function getSeriesOption() {
    const { name: name2, data, ...rest } = props;
    return _merge18({
      type: "tree",
      name: name2,
      data,
      symbolSize: 8,
      itemStyle: {
        color: "#34c3ff",
        borderColor: "#34c3ff",
        borderWidth: 2
      },
      label: {
        position: "left",
        verticalAlign: "middle",
        align: "right"
      },
      leaves: {
        label: {
          position: "right",
          verticalAlign: "middle",
          align: "left"
        }
      }
    }, rest);
  }
  if (!option.series) {
    option.series = [];
  }
  option.series.push(getSeriesOption());
};
if (process.env.NODE_ENV !== "production") {
  Tree.displayName = "Tree";
}
var Tree_default = Tree;

// src/series/Treemap.ts
import * as echarts18 from "echarts/core";
import { TreemapChart } from "echarts/charts";
import _merge19 from "lodash.merge";
echarts18.use([TreemapChart]);
var Treemap = () => null;
Treemap.defaultProps = {
  data: []
};
Treemap[symbols.typeKey] = symbols.treemap;
Treemap.tapEChartsOption = (option, props) => {
  function transformData(node) {
    if (!node) {
      return node;
    }
    if (!Array.isArray(node)) {
      return node;
    }
    const [name2, value, children] = node;
    return {
      name: name2,
      value,
      children: children && children.map(transformData)
    };
  }
  function getSeriesOption() {
    const { data, ...rest } = props;
    return _merge19({
      type: "treemap",
      data: data == null ? void 0 : data.map(transformData),
      itemStyle: {
        areaColor: "#BEDBED",
        borderColor: "#ffffff",
        borderWidth: 1
      },
      visibleMin: 300,
      leafDepth: 1,
      drillDownIcon: null,
      label: {
        position: "insideTopLeft",
        color: "#ffffff",
        fontSize: 12,
        lineHeight: 17,
        formatter({ name: name2, value }) {
          return `{a|${name2}
${value}}`;
        },
        rich: {
          a: {
            color: "#ffffff",
            fontSize: 12,
            lineHeight: 17
          }
        }
      },
      levels: [
        {
          itemStyle: {
            borderColor: "#fff",
            borderWidth: 1,
            gapWidth: 1
          }
        }
      ]
    }, rest);
  }
  if (!option.series) {
    option.series = [];
  }
  option.series.push(getSeriesOption());
};
if (process.env.NODE_ENV !== "production") {
  Treemap.displayName = "Treemap";
}
var Treemap_default = Treemap;

// src/charts/BarChart.tsx
import React5, { Children, cloneElement } from "react";
var categoryAxisProps = {
  type: "category",
  splitLine: false
};
var valueAxisProps = {
  type: "value"
};
function BarChart2({
  name: name2,
  data: inputData = [],
  tooltip = true,
  xAxis = true,
  yAxis = true,
  horizontal = false,
  legend = true,
  children,
  ...props
}, ref) {
  function renderDefaultCategoryAxis() {
    const data2 = horizontal ? [...inputData].reverse() : inputData;
    const categories = data2.map(([category]) => category);
    return horizontal ? /* @__PURE__ */ React5.createElement(YAxis_default, {
      ...categoryAxisProps,
      data: categories
    }) : /* @__PURE__ */ React5.createElement(XAxis_default, {
      ...categoryAxisProps,
      data: categories
    });
  }
  function renderDefaultValueAxis() {
    return horizontal ? /* @__PURE__ */ React5.createElement(XAxis_default, {
      ...valueAxisProps,
      show: xAxis
    }) : /* @__PURE__ */ React5.createElement(YAxis_default, {
      ...valueAxisProps,
      show: yAxis
    });
  }
  function renderDefaultSeries() {
    const data2 = horizontal ? [...inputData].reverse() : inputData;
    const values = data2.map((d) => d[1]);
    return /* @__PURE__ */ React5.createElement(Bars_default, {
      name: name2,
      data: values
    });
  }
  const components = Children.toArray(children);
  const series = components.filter(isSeries);
  const data = horizontal ? [...inputData].reverse() : inputData;
  const categoryAxis = horizontal ? components.find((comp) => is(comp, "yAxis")) : components.find((comp) => is(comp, "xAxis"));
  const valueAxis = horizontal ? components.find((comp) => is(comp, "xAxis")) : components.find((comp) => is(comp, "yAxis"));
  return /* @__PURE__ */ React5.createElement(EChartsContext.Provider, {
    value: { chartType: "bar", horizontal }
  }, /* @__PURE__ */ React5.createElement(ECharts_default, {
    ref,
    ...props
  }, !categoryAxis && renderDefaultCategoryAxis(), !valueAxis && renderDefaultValueAxis(), !components.find((comp) => is(comp, "bars")) && renderDefaultSeries(), legend && !components.find((comp) => is(comp, "legend")) && /* @__PURE__ */ React5.createElement(Legend_default, null), tooltip && /* @__PURE__ */ React5.createElement(Tooltip_default, null), components.map((child) => {
    if (child.type === (horizontal ? YAxis_default : XAxis_default)) {
      return cloneElement(child, {
        ...categoryAxisProps,
        data: child.props.data || data.map(([category]) => category)
      });
    }
    if (child.type === (horizontal ? XAxis_default : YAxis_default)) {
      return cloneElement(child, valueAxisProps);
    }
    if (data.length && isSeries(child) && !child.props.data) {
      const serieIndex = series.indexOf(child);
      return cloneElement(child, { data: data.map((d) => d[serieIndex + 1]) });
    }
    return child;
  })));
}
var BarChart_default = React5.forwardRef(BarChart2);

// src/charts/FunnelChart.tsx
import React6, { Children as Children2, Fragment, cloneElement as cloneElement2 } from "react";
import _merge20 from "lodash.merge";
var funnelDefaultWidth = 40;
function FunnelChart2({ asc = false, tooltip = true, name: name2, data = [], children, option, ...props }, ref) {
  const components = Children2.toArray(children);
  const funnels = components.filter((comp) => is(comp, "funnel"));
  const legends = components.filter((comp) => is(comp, "legend"));
  const withoutLegend = legends.length === 0;
  function renderDefaultFunnel() {
    const funnelPosition = {
      width: `${funnelDefaultWidth}%`,
      left: `${(100 - funnelDefaultWidth) / 2}%`
    };
    return /* @__PURE__ */ React6.createElement(Fragment, null, /* @__PURE__ */ React6.createElement(Funnel_default, {
      name: name2,
      data,
      asc,
      ...funnelPosition
    }), withoutLegend && /* @__PURE__ */ React6.createElement(Legend_default, {
      data: data.map(([name3]) => name3)
    }));
  }
  function renderFunnels(funnels2) {
    if (funnels2.length === 1) {
      const funnelPosition = {
        width: `${funnelDefaultWidth}%`,
        left: `${(100 - funnelDefaultWidth) / 2}%`
      };
      return funnels2.map((funnel, index) => /* @__PURE__ */ React6.createElement(Fragment, {
        key: index
      }, cloneElement2(funnel, { ...funnelPosition, ...funnel.props }), withoutLegend && /* @__PURE__ */ React6.createElement(Legend_default, {
        data: funnel.props.data.map(([name3]) => name3)
      })));
    }
    const occupiedColorsCount = (index) => funnels2.slice(0, index).reduce((sum, funnel) => sum + funnel.props.data.length, 0);
    if (funnels2.length === 2) {
      return funnels2.map((funnel, index) => {
        const funnelPosition = {
          width: `${funnelDefaultWidth}%`,
          left: `${5 + 50 * index}%`
        };
        return /* @__PURE__ */ React6.createElement(Fragment, {
          key: index
        }, cloneElement2(funnel, {
          ...funnelPosition,
          color: funnel.props.color && new Array(occupiedColorsCount(index)).concat(funnel.props.color),
          ...funnel.props
        }), withoutLegend && /* @__PURE__ */ React6.createElement(Legend_default, {
          data: funnel.props.data.map(([name3]) => name3),
          ...funnelPosition
        }));
      });
    }
    return funnels2.map((funnel, index) => /* @__PURE__ */ React6.createElement(Fragment, {
      key: index
    }, cloneElement2(funnel, {
      color: funnel.props.color && new Array(occupiedColorsCount(index)).concat(funnel.props.color)
    }), withoutLegend && /* @__PURE__ */ React6.createElement(Legend_default, {
      data: funnel.props.data.map(([name3]) => name3)
    })));
  }
  let titleOption = {};
  if (!funnels.length) {
    titleOption = {
      title: {
        text: name2,
        left: "50%",
        top: "10%",
        textAlign: "center",
        textVerticalAlign: "bottom",
        textStyle: { color: "#272c36", fontSize: 14, fontWeight: "normal" }
      }
    };
  }
  if (funnels.length <= 2) {
    titleOption = {
      title: funnels.map((funnel, index) => ({
        text: funnel.props.name,
        left: `${funnels.length === 1 ? 50 : 5 + funnelDefaultWidth / 2 + index * 50}%`,
        top: "10%",
        textAlign: "center",
        textVerticalAlign: "bottom",
        textStyle: { color: "#272c36", fontSize: 14, fontWeight: "normal" }
      }))
    };
  }
  return /* @__PURE__ */ React6.createElement(EChartsContext.Provider, {
    value: { chartType: "funnel", dataName: name2 }
  }, /* @__PURE__ */ React6.createElement(ECharts_default, {
    ref,
    option: _merge20(titleOption, option),
    ...props
  }, !funnels.length && renderDefaultFunnel(), funnels.length > 0 && renderFunnels(funnels), tooltip && /* @__PURE__ */ React6.createElement(Tooltip_default, null), components.filter((comp) => !is(comp, "funnel"))));
}
var FunnelChart_default = React6.forwardRef(FunnelChart2);

// src/charts/LineChart.tsx
import React7, { Children as Children3, cloneElement as cloneElement3 } from "react";
function LineChart2({ name: name2, data = [], tooltip = true, children, ...props }, ref) {
  function renderDefaultXAxis() {
    return /* @__PURE__ */ React7.createElement(XAxis_default, {
      ...{ data: data.map(([category]) => category) }
    });
  }
  function renderDefaultLine() {
    return /* @__PURE__ */ React7.createElement(Line_default, {
      name: name2,
      data: data.map((d) => d[1])
    });
  }
  const components = Children3.toArray(children);
  const series = components.filter(isSeries);
  return /* @__PURE__ */ React7.createElement(EChartsContext.Provider, {
    value: { chartType: "line" }
  }, /* @__PURE__ */ React7.createElement(ECharts_default, {
    ref,
    ...props
  }, !components.find((comp) => is(comp, "xAxis")) && renderDefaultXAxis(), !components.find((comp) => is(comp, "yAxis")) && /* @__PURE__ */ React7.createElement(YAxis_default, null), !components.find((comp) => is(comp, "line")) && renderDefaultLine(), tooltip && /* @__PURE__ */ React7.createElement(Tooltip_default, null), !components.find((comp) => is(comp, "legend")) && /* @__PURE__ */ React7.createElement(Legend_default, null), components.map((child) => {
    if (data.length && isSeries(child) && !child.props.data) {
      const serieIndex = series.indexOf(child);
      return cloneElement3(child, { data: data.map((d) => d[serieIndex + 1]) });
    }
    return child;
  })));
}
var LineChart_default = React7.forwardRef(LineChart2);

// src/charts/MapChart.tsx
import React8, { Children as Children4 } from "react";
import _merge21 from "lodash.merge";
var mapVisualMapColors = [
  "rgb(8, 132, 204)",
  "rgba(8, 132, 204, .8)",
  "rgba(8, 132, 204, .6)",
  "rgba(8, 132, 204, .4)",
  "rgba(8, 132, 204, .3)"
];
function MapChart2({ name: name2, data = [], visualMap: shouldShowVisualMap = true, children, ...props }, ref) {
  function renderDefaultMap() {
    return /* @__PURE__ */ React8.createElement(Map_default, {
      name: name2,
      data,
      ...props
    });
  }
  const components = Children4.toArray(children);
  const compVisualMap = components.find((comp) => is(comp, "visualMap"));
  const visualMapProps = {
    show: shouldShowVisualMap !== false,
    type: "piecewise",
    inRange: {
      color: [...mapVisualMapColors].reverse()
    },
    controller: {
      symbol: "rect"
    }
  };
  const map = components.find((comp) => is(comp, "map"));
  return /* @__PURE__ */ React8.createElement(EChartsContext.Provider, {
    value: { chartType: "map", dataName: name2, chartData: data }
  }, /* @__PURE__ */ React8.createElement(ECharts_default, {
    ref,
    ...props
  }, /* @__PURE__ */ React8.createElement(Tooltip_default, null), !compVisualMap && /* @__PURE__ */ React8.createElement(VisualMap_default, {
    ...visualMapProps
  }), !map && renderDefaultMap(), components.map((child) => {
    if (child.type === VisualMap_default) {
      return React8.cloneElement(child, _merge21(visualMapProps, child.props));
    }
    return child;
  })));
}
var MapChart_default = React8.forwardRef(MapChart2);

// src/charts/PieChart.tsx
import React9, { Children as Children5 } from "react";
function PieChart2({ data = [], legend = true, children, ...props }, ref) {
  const components = Children5.toArray(children);
  function getPieData() {
    return data.map(([name2, value]) => ({ name: name2, value }));
  }
  return /* @__PURE__ */ React9.createElement(EChartsContext.Provider, {
    value: { chartType: "pie" }
  }, /* @__PURE__ */ React9.createElement(ECharts_default, {
    ref,
    ...props
  }, legend === true && !components.some((comp) => is(comp, "legend")) && /* @__PURE__ */ React9.createElement(Legend_default, null), !components.some((comp) => is(comp, "tooltip")) && /* @__PURE__ */ React9.createElement(Tooltip_default, null), !components.some((comp) => is(comp, "pie")) && /* @__PURE__ */ React9.createElement(Pie_default, {
    data: getPieData(),
    ...props
  }), children));
}
var PieChart_default = React9.forwardRef(PieChart2);

// src/charts/RadarChart.tsx
import React10, { Children as Children6, cloneElement as cloneElement4 } from "react";
function RadarChart2({ name: name2, data = [], tooltip = true, legend = true, children, ...props }, ref) {
  function renderDefaultRadar() {
    const indicator = data.map(([name3, max]) => ({ name: name3, max }));
    return /* @__PURE__ */ React10.createElement(Radar_default, {
      indicator
    });
  }
  function renderDefaultRadarLine() {
    return /* @__PURE__ */ React10.createElement(RadarLine_default, {
      name: name2,
      data: data.map(([, , value]) => value)
    });
  }
  const components = Children6.toArray(children);
  const series = components.filter(isSeries);
  return /* @__PURE__ */ React10.createElement(EChartsContext.Provider, {
    value: { chartType: "radar", dataName: name2 }
  }, /* @__PURE__ */ React10.createElement(ECharts_default, {
    ref,
    ...props
  }, !components.find((comp) => is(comp, "radar")) && renderDefaultRadar(), !components.find((comp) => is(comp, "radarLine")) && renderDefaultRadarLine(), tooltip && /* @__PURE__ */ React10.createElement(Tooltip_default, null), legend && /* @__PURE__ */ React10.createElement(Legend_default, {
    icon: "rect",
    itemWidth: 14
  }), components.map((child) => {
    if (data.length && isSeries(child) && !child.props.data) {
      const serieIndex = series.indexOf(child);
      return cloneElement4(child, { data: data.map((d) => d[serieIndex + 2]) });
    }
    return child;
  })));
}
if (process.env.NODE_ENV !== "production") {
  RadarChart2.displayName = "RadarChart";
}
var RadarChart_default = React10.forwardRef(RadarChart2);

// src/charts/SankeyChart.tsx
import React11, { Children as Children7 } from "react";
function SankeyChart2({ name: name2, data = [], children, ...props }, ref) {
  function renderDefaultSankey() {
    return /* @__PURE__ */ React11.createElement(Sankey_default, {
      name: name2,
      ...data
    });
  }
  const components = Children7.toArray(children);
  const sankey = components.find((comp) => is(comp, "sankey"));
  return /* @__PURE__ */ React11.createElement(EChartsContext.Provider, {
    value: { chartType: "sankey", dataName: name2 }
  }, /* @__PURE__ */ React11.createElement(ECharts_default, {
    ref,
    ...props
  }, /* @__PURE__ */ React11.createElement(Tooltip_default, null), !sankey && renderDefaultSankey(), children));
}
var SankeyChart_default = React11.forwardRef(SankeyChart2);

// src/charts/ScatterChart.tsx
import React12, { Children as Children8, cloneElement as cloneElement5 } from "react";
import _merge22 from "lodash.merge";
var xAxisProps = {
  axisLine: {
    symbol: ["none", "arrow"],
    symbolSize: [9, 9]
  },
  nameLocation: "middle",
  nameGap: 25,
  nameTextStyle: {
    fontSize: 14,
    color: "#272c36"
  }
};
var yAxisProps = {
  axisLine: {
    show: true,
    symbol: ["none", "arrow"],
    symbolSize: [9, 9]
  },
  splitLine: false,
  nameLocation: "middle",
  nameGap: 35,
  nameTextStyle: {
    fontSize: 14,
    lineHeight: 20,
    color: "#272c36"
  }
};
function ScatterChart2({ name: name2, data = [], tooltip = true, legend = true, children, ...props }, ref) {
  function renderDefaultScatter() {
    return /* @__PURE__ */ React12.createElement(Scatter_default, {
      name: name2,
      data
    });
  }
  const components = Children8.toArray(children);
  return /* @__PURE__ */ React12.createElement(EChartsContext.Provider, {
    value: { chartType: "scatter", dataName: name2 }
  }, /* @__PURE__ */ React12.createElement(ECharts_default, {
    ref,
    ...props
  }, !components.find((comp) => is(comp, "xAxis")) && /* @__PURE__ */ React12.createElement(XAxis_default, {
    ...xAxisProps
  }), !components.find((comp) => is(comp, "yAxis")) && /* @__PURE__ */ React12.createElement(YAxis_default, {
    ...yAxisProps
  }), !components.find((comp) => is(comp, "scatter")) && renderDefaultScatter(), tooltip && /* @__PURE__ */ React12.createElement(Tooltip_default, null), legend && /* @__PURE__ */ React12.createElement(Legend_default, {
    icon: "circle",
    itemHeight: 10,
    itemWidth: 10,
    itemGap: 30
  }), components.map((child) => {
    if (is(child, "xAxis")) {
      return cloneElement5(child, _merge22(xAxisProps, child.props));
    }
    if (is(child, "yAxis")) {
      return cloneElement5(child, _merge22(yAxisProps, child.props));
    }
    return child;
  })));
}
var ScatterChart_default = React12.forwardRef(ScatterChart2);

// src/charts/TreeChart.tsx
import React13, { Children as Children9 } from "react";
function TreeChart2({ data = [], children, ...props }, ref) {
  function renderDefaultTree() {
    return /* @__PURE__ */ React13.createElement(Tree_default, {
      data
    });
  }
  const components = Children9.toArray(children);
  const tree = components.find((comp) => is(comp, "tree"));
  return /* @__PURE__ */ React13.createElement(EChartsContext.Provider, {
    value: { chartType: "tree", dataName: name }
  }, /* @__PURE__ */ React13.createElement(ECharts_default, {
    ref,
    ...props
  }, /* @__PURE__ */ React13.createElement(Tooltip_default, null), !tree && renderDefaultTree(), children));
}
var TreeChart_default = React13.forwardRef(TreeChart2);

// src/charts/TreemapChart.tsx
import React14, { Children as Children10 } from "react";
var treemapTooltipFormatter = ({ seriesName, name: name2, value }) => `${name2}<br>${seriesName}: ${value}`;
function TreemapChart2({ name: name2, data = [], children, ...props }, ref) {
  function renderDefaultTreemap() {
    return /* @__PURE__ */ React14.createElement(Treemap_default, {
      name: name2,
      data
    });
  }
  const components = Children10.toArray(children);
  const treemap = components.find((comp) => is(comp, "treemap"));
  return /* @__PURE__ */ React14.createElement(EChartsContext.Provider, {
    value: { chartType: "treemap", dataName: name2 }
  }, /* @__PURE__ */ React14.createElement(ECharts_default, {
    ref,
    ...props
  }, /* @__PURE__ */ React14.createElement(Tooltip_default, {
    formatter: treemapTooltipFormatter
  }), /* @__PURE__ */ React14.createElement(VisualMap_default, null), !treemap && renderDefaultTreemap(), children));
}
var TreemapChart_default = React14.forwardRef(TreemapChart2);

// src/index.ts
var src_default = ECharts_default;
export {
  BarChart_default as BarChart,
  Bars_default as Bars,
  DataZoom_default as DataZoom,
  Dataset_default as Dataset,
  Funnel_default as Funnel,
  FunnelChart_default as FunnelChart,
  Legend_default as Legend,
  Line_default as Line,
  LineChart_default as LineChart,
  Map_default as Map,
  MapChart_default as MapChart,
  Pie_default as Pie,
  PieChart_default as PieChart,
  Radar_default as Radar,
  RadarChart_default as RadarChart,
  RadarLine_default as RadarLine,
  Sankey_default as Sankey,
  SankeyChart_default as SankeyChart,
  Scatter_default as Scatter,
  ScatterChart_default as ScatterChart,
  Tooltip_default as Tooltip,
  Tree_default as Tree,
  TreeChart_default as TreeChart,
  Treemap_default as Treemap,
  TreemapChart_default as TreemapChart,
  VisualMap_default as VisualMap,
  XAxis_default as XAxis,
  YAxis_default as YAxis,
  src_default as default
};
